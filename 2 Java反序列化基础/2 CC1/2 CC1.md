**注意：需要实操**

**必看**：

[Java安全漫谈 - 09.初识CommonsCollections](https://t.zsxq.com/BmIIAy3)

[Java反序列化Commons-Collections篇01-CC1链](https://drun1baby.github.io/2022/06/06/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Commons-Collections%E7%AF%8701-CC1%E9%93%BE/#toc-heading-2)

[CommonsCollections1笔记](https://github.com/Y4tacker/JavaSec/blob/main/2.%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%93%E5%8C%BA/CommonsCollections1/CommonsCollections1.md)

### 环境搭建

查看 `在pom.xml中添加依赖包，确定依赖包成功导入，在项目中import依赖包`:

https://blog.csdn.net/qq_41854911/article/details/122159068

---



**回调函数**：主程序传`函数`给API，API会拿去执行

打个比方，有一个餐馆，提供`炒菜`的服务，但是会让我们选择做菜的方式，我们告诉他想吃小龙虾后，他会询问我们要以`何种方式`去进行烹饪,是炒还是煮。

- 炒菜服务：即API
- 何种方式：即传入的函数

---

TransformedMap在转换Map的新元素时，就会调⽤transform⽅法，这个过程就类似在调⽤⼀个”回调函数“，这个回调的参数是原始对象。

### 命令执行的关键

InvokerTransformer这个类可以⽤来执⾏任意⽅法，这也是反序列化能执⾏任意代码的关键。

在实例化这个InvokerTransformer时，需要传⼊三个参数，第⼀个参数是待执行的方法名，第⼆个参数是这个函数的参数列表的参数类型，第三个参数是传给这个函数的参数列表

`InvokerTransformer`类的`transform`方法中用到了反射，只要传参进去就能反射加载对应的方法

关键地方：

```java
try {
Class cls = input.getClass();
Method method = cls.getMethod(iMethodName, iParamTypes);
return method.invoke(input, iArgs);
}
```





实例化的是数组不是Transformer接口：

Transformer[] transformers = new Transformer[]{`...`}



chain:

(这里的`1,2,3`只是参数1，参数2，参数3的意思,下同)

```md

TransformedMap.decorate()	静态方法
	TransformedMap.TransformedMap(1,2,3)
        TransformedMap.checkSetValue(1)
                TransformedMap.transform()
```

先初始化:

```md
TransformedMap.decorate(1,2,3)	静态方法
	TransformedMap.TransformedMap(1,2,3)
```

再调用 `TransformedMap.checkSetValue()` 去激活 `TransformedMap.transform()`,从而达到命令执行的目的



为什么需要 hashMap对象：为了构造 `TransformedMap.decorate()`方法，它要什么参数就给它什么参数





### 为什么要去找调用 `transform` 方法的不同名函数


为了调用checkSetValue函数时，能触发  `valueTransformer.transform(value)`

从而形成 **InvokerTransformer.transform()**，也就达成了命令执行的目的**（参见[命令执行的关键]）**

```java

protected Object checkSetValue(Object value) {
       return valueTransformer.transform(value);
    }
```



对这句不是很了解：2023.1.6号研究

checkSetValueMethod.invoke(tranformedMap, runtime);