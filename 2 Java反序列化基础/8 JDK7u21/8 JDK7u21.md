## 1.前言

必读：

[Java安全漫谈 - 18.原生反序列化利用链JDK7u21](https://t.zsxq.com/neMbuJa)



jdk 7u21下载：

https://www.123pan.com/s/xPY9-86lvH

源码下载：

https://hg.openjdk.java.net/jdk7u/jdk7u2/jdk/rev



maven配置：

```md
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>jdk7u21</groupId>
    <artifactId>jdk7u21</artifactId>
    <version>1.0-SNAPSHOT</version>

    <dependencies>
        <dependency>
            <groupId>org.javassist</groupId>
            <artifactId>javassist</artifactId>
            <version>3.19.0-GA</version>
        </dependency>
    </dependencies>
</project>
```



---

### JDK7u21解决了什么问题：

之前的各种链子都有依赖库，那么有没有不需要依赖库的链子呢。答案是 **JDK7u21 ，它适用于Java 7u21及以前的版本 。**

---

### JDK7u21的核心原理

JDK7u21的核心点就是 **sun.reflect.annotation.AnnotationInvocationHandler** 类，该类有个equalsImpl方法



`AnnotationInvocationHandler#equalsImpl`方法：

这个方法中有个很明显的反射调用 `memberMethod.invoke(o)` ，而 `memberMethod` 来自于
`this.type.getDeclaredMethods()` 。
也就是说， `equalsImpl` 这个方法是将 `this.type` 类中的所有方法遍历并执行了。那么，假设
`this.type` 是`Templates`类，则势必会调用到其中的 `newTransformer() 或 getOutputProperties()`
方法，进而触发任意代码执行。
这就是JDK7u21的核心原理。

​																						——[Java安全漫谈 - 18.原生反序列化利用链JDK7u21](https://t.zsxq.com/neMbuJa)

---

### 如何调用equalsImpl

 `equalsImpl` 是一个私有方法，在`AnnotationInvocationHandler#invoke` 中被调用,之前CC1 LazyMap 讲过动态代理【参考 2 CC1链.md】，因此我们想调用 `AnnotationInvocationHandler#invoke`，必须使用动态代理

`AnnotationInvocationHandler#invoke`（关键地方）：

```java
if (member.equals("equals") && paramTypes.length == 1 &&
            paramTypes[0] == Object.class)
            return equalsImpl(args[0]);
```



可见，当方法名等于“equals”，且仅有一个Object类型参数时，会调用到 equalImpl 方法。
所以，现在的问题变成，我们需要找到一个方法，在反序列化时对proxy调用equals方法。

​																						——[Java安全漫谈 - 18.原生反序列化利用链JDK7u21](https://t.zsxq.com/neMbuJa)

---

### 找到equals方法调用链

集合set。set中储存的对象不允许重复，所以在添加对象的时候，势必会涉及到比较操作,**会调用 equals**。

为什么不用 `java.util.PriorityQueue`，因为其中用的是compareTo，而非equals。



HashSet的readObject方法（核心部分）：

```java
map = (((HashSet)this) instanceof LinkedHashSet ?
     new LinkedHashMap<E,Object>(capacity, loadFactor) :
     new HashMap<E,Object>(capacity, loadFactor));
```

使用了一个HashMap，将对象保存在HashMap的key处来做去重。



HashMap，就是数据结构里的哈希表，相信上过数据结构课程的同学应该还记得，哈希表是由数组+链
表实现的——哈希表底层保存在一个数组中，数组的索引由哈希表的 key.hashCode() 经过计算得到，
数组的值是一个链表，所有哈希碰撞到相同索引的key-value，都会被链接到这个链表后面。

​																						——[Java安全漫谈 - 18.原生反序列化利用链JDK7u21](https://t.zsxq.com/neMbuJa)

#### equals方法调用链的核心诉求：

所以，为了触发比较操作，**我们需要让比较与被比较的两个对象的哈希相同**，这样才能被连接到同一条
链表上，才会进行比较。